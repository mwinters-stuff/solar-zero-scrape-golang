// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	api "github.com/influxdata/influxdb-client-go/v2/api"

	domain "github.com/influxdata/influxdb-client-go/v2/domain"

	mock "github.com/stretchr/testify/mock"
)

// QueryAPI is an autogenerated mock type for the QueryAPI type
type QueryAPI struct {
	mock.Mock
}

type QueryAPI_Expecter struct {
	mock *mock.Mock
}

func (_m *QueryAPI) EXPECT() *QueryAPI_Expecter {
	return &QueryAPI_Expecter{mock: &_m.Mock}
}

// Query provides a mock function with given fields: ctx, query
func (_m *QueryAPI) Query(ctx context.Context, query string) (*api.QueryTableResult, error) {
	ret := _m.Called(ctx, query)

	var r0 *api.QueryTableResult
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.QueryTableResult); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.QueryTableResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryAPI_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type QueryAPI_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//  - ctx context.Context
//  - query string
func (_e *QueryAPI_Expecter) Query(ctx interface{}, query interface{}) *QueryAPI_Query_Call {
	return &QueryAPI_Query_Call{Call: _e.mock.On("Query", ctx, query)}
}

func (_c *QueryAPI_Query_Call) Run(run func(ctx context.Context, query string)) *QueryAPI_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *QueryAPI_Query_Call) Return(_a0 *api.QueryTableResult, _a1 error) *QueryAPI_Query_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// QueryRaw provides a mock function with given fields: ctx, query, dialect
func (_m *QueryAPI) QueryRaw(ctx context.Context, query string, dialect *domain.Dialect) (string, error) {
	ret := _m.Called(ctx, query, dialect)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, *domain.Dialect) string); ok {
		r0 = rf(ctx, query, dialect)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *domain.Dialect) error); ok {
		r1 = rf(ctx, query, dialect)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryAPI_QueryRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRaw'
type QueryAPI_QueryRaw_Call struct {
	*mock.Call
}

// QueryRaw is a helper method to define mock.On call
//  - ctx context.Context
//  - query string
//  - dialect *domain.Dialect
func (_e *QueryAPI_Expecter) QueryRaw(ctx interface{}, query interface{}, dialect interface{}) *QueryAPI_QueryRaw_Call {
	return &QueryAPI_QueryRaw_Call{Call: _e.mock.On("QueryRaw", ctx, query, dialect)}
}

func (_c *QueryAPI_QueryRaw_Call) Run(run func(ctx context.Context, query string, dialect *domain.Dialect)) *QueryAPI_QueryRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*domain.Dialect))
	})
	return _c
}

func (_c *QueryAPI_QueryRaw_Call) Return(_a0 string, _a1 error) *QueryAPI_QueryRaw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// QueryRawWithParams provides a mock function with given fields: ctx, query, dialect, params
func (_m *QueryAPI) QueryRawWithParams(ctx context.Context, query string, dialect *domain.Dialect, params interface{}) (string, error) {
	ret := _m.Called(ctx, query, dialect, params)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, *domain.Dialect, interface{}) string); ok {
		r0 = rf(ctx, query, dialect, params)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *domain.Dialect, interface{}) error); ok {
		r1 = rf(ctx, query, dialect, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryAPI_QueryRawWithParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRawWithParams'
type QueryAPI_QueryRawWithParams_Call struct {
	*mock.Call
}

// QueryRawWithParams is a helper method to define mock.On call
//  - ctx context.Context
//  - query string
//  - dialect *domain.Dialect
//  - params interface{}
func (_e *QueryAPI_Expecter) QueryRawWithParams(ctx interface{}, query interface{}, dialect interface{}, params interface{}) *QueryAPI_QueryRawWithParams_Call {
	return &QueryAPI_QueryRawWithParams_Call{Call: _e.mock.On("QueryRawWithParams", ctx, query, dialect, params)}
}

func (_c *QueryAPI_QueryRawWithParams_Call) Run(run func(ctx context.Context, query string, dialect *domain.Dialect, params interface{})) *QueryAPI_QueryRawWithParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*domain.Dialect), args[3].(interface{}))
	})
	return _c
}

func (_c *QueryAPI_QueryRawWithParams_Call) Return(_a0 string, _a1 error) *QueryAPI_QueryRawWithParams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// QueryWithParams provides a mock function with given fields: ctx, query, params
func (_m *QueryAPI) QueryWithParams(ctx context.Context, query string, params interface{}) (*api.QueryTableResult, error) {
	ret := _m.Called(ctx, query, params)

	var r0 *api.QueryTableResult
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *api.QueryTableResult); ok {
		r0 = rf(ctx, query, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.QueryTableResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, query, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryAPI_QueryWithParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryWithParams'
type QueryAPI_QueryWithParams_Call struct {
	*mock.Call
}

// QueryWithParams is a helper method to define mock.On call
//  - ctx context.Context
//  - query string
//  - params interface{}
func (_e *QueryAPI_Expecter) QueryWithParams(ctx interface{}, query interface{}, params interface{}) *QueryAPI_QueryWithParams_Call {
	return &QueryAPI_QueryWithParams_Call{Call: _e.mock.On("QueryWithParams", ctx, query, params)}
}

func (_c *QueryAPI_QueryWithParams_Call) Run(run func(ctx context.Context, query string, params interface{})) *QueryAPI_QueryWithParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *QueryAPI_QueryWithParams_Call) Return(_a0 *api.QueryTableResult, _a1 error) *QueryAPI_QueryWithParams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

type mockConstructorTestingTNewQueryAPI interface {
	mock.TestingT
	Cleanup(func())
}

// NewQueryAPI creates a new instance of QueryAPI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewQueryAPI(t mockConstructorTestingTNewQueryAPI) *QueryAPI {
	mock := &QueryAPI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
